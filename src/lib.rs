use bellman::{Circuit, ConstraintSystem, LinearCombination, SynthesisError, Variable};
use bellman::Index::Input;
use num::BigUint;
use pairing::Engine;
use r1cs::{Constraint, Expression, Field, Gadget, Wire};

pub struct WrappedCircuit<F: Field> {
    gadget: Gadget<F>,
}

impl<F: Field, E: Engine> Circuit<E> for WrappedCircuit<F> where E::Fr: From<BigUint> {
    fn synthesize<CS: ConstraintSystem<E>>(self, cs: &mut CS) -> Result<(), SynthesisError> {
        for constraint in self.gadget.constraints {
            let Constraint { a, b, c } = constraint;
            cs.enforce(
                || "generated by r1cs-bellman",
                |_lc| convert_lc(a),
                |_lc| convert_lc(b),
                |_lc| convert_lc(c),
            );
        }
        Ok(())
    }
}

fn convert_lc<F: Field, E: Engine>(exp: Expression<F>) -> LinearCombination<E>
    where E::Fr: From<BigUint> {
    // This is inefficient, but bellman doesn't expose a LinearCombination constructor taking an
    // entire variable/coefficient map, so we have to build one up with repeated addition.
    let mut sum = LinearCombination::zero();
    for (wire, coeff) in exp.coefficients() {
        let fr = E::Fr::from(coeff.to_biguint().clone());
        sum = sum + (fr, convert_wire(*wire));
    }
    sum
}

fn convert_wire(wire: Wire) -> Variable {
    Variable::new_unchecked(Input(wire.index as usize))
}
